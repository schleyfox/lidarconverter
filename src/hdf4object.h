#ifndef HDF4OBJECT_H
#define HDF4OBJECT_H

#include "mfhdf.h"
#include <string>
#include <iostream>
#include <fstream>

/** 
 * hdf4object.h
 * HDF4Object Class
 * A more objective way to read data from HDF files.
 *
 * @author T. Nelson Hillyer, DEVELOP National Program, NASA
 * 
 * date: March 3, 2008
 * version: 0.4 (BETA)
 */
class hdf4object
{
	public:
		hdf4object(std::string* filename);
		~hdf4object();

		std::string* getDataSets();
		int getNumberOfSets();
		int getSetRank(std::string* setName);
		int* getSetDimensions(std::string* setName);
		template <class T>
		T** setToArray(std::string* setName);
		template <class T>
		bool setToFile(std::string* setName, std::string* fileName);
		template <class T>
		void freeArray(T** array);
	
	private:
		int32 sd_id, sds_id;
		intn status;
		int32 n_datasets, n_file_attrs, index;
		int32 dim_sizes[MAX_VAR_DIMS];
		int32 rank, data_type, n_attrs;

		char name[MAX_NC_NAME];
		std::string* setNames;
		int* setRank;
		int** setDimensions;
};


/**
 * Constructor for the hdf4object class.  In the event of a file I/O error,
 * the program is terminated.
 */
inline hdf4object::hdf4object(std::string* filename)
{
	sd_id = SDstart(filename->c_str(), DFACC_READ);
	status = SDfileinfo(sd_id, &n_datasets, &n_file_attrs);
	if (status == -1) {
		std::cerr << "FILE I/O FAILURE!" << std::endl;
		exit(EXIT_FAILURE);
	}

	setNames = new std::string[n_datasets];
	setRank = new int[n_datasets];
	setDimensions = new int*[n_datasets];

	for (int i = 0; i < n_datasets; i++)
	{
		sds_id = SDselect(sd_id, i);
		status = SDgetinfo(sds_id, name, &rank, dim_sizes, &data_type,
			&n_attrs);
		setNames[i] = name;
		setRank[i] = rank;
		setDimensions[i] = new int[rank];

		for (int j = 0; j < rank; j++) 
			setDimensions[i][j] = dim_sizes[j];
	}
}

/**
 * Destructor for the hdf4object.
 * Closes access to the hdf4object.
 */
inline hdf4object::~hdf4object()
{
	status = SDendaccess(sds_id);
	status = SDend(sd_id);
	delete [] setNames;
	delete [] setRank;
}

/**
 * Get the names of the data sets stored in the working HDF4 file.
 */
inline std::string* hdf4object::getDataSets()
{
	return setNames;
}

/**
 * Get the rank (or number of dimensions) for the specified set.
 * Returns -1 for nonexistent set.
 */
inline int hdf4object::getSetRank(std::string* setName)
{
	for (int i = 0; i < n_datasets; i++)
	{
		if (setNames[i] == *setName)
			return setRank[i];
	}
	return -1;
}

/**
 * Returns the number of sets in the HDF4 file.
 */
inline int hdf4object::getNumberOfSets()
{
	return n_datasets;
}

/**
 * Returns the dimensions of specified set in the HDF4 file.
 * NOTE: Returns NULL in the event of non-existent set.
 * EXAMPLE: For a set of dimensions 3x7x5, an array of integers
 * will be returned {3, 7, 5}.
 */
inline int* hdf4object::getSetDimensions(std::string* setName)
{
	for (int i = 0; i < n_datasets; i++)
	{
		if (setNames[i] == *setName)
			return setDimensions[i];
	}
	return NULL;
}

/**
 * Converts the specified set into an array of equivalent dimensions.
 */
template <class T>
T** hdf4object::setToArray(std::string* setName)
{
	for (int i = 0; i < n_datasets; i++)
	{
		if (setNames[i] == *setName)
		{
			if (setDimensions[i][1] == 0)
			{
				sds_id = SDselect(sd_id, i);
				int32 start[setRank[i]], edges[setRank[i]];

				T** array = (T **)malloc(setDimensions[i][0] * sizeof(T *));
				array[0] = (T *)malloc(setDimensions[i][0] * sizeof(T));
				
				start[0] = 0; start[1] = 0;
				edges[0] = setDimensions[i][0]; edges[1] = 1;
				status = SDreaddata(sds_id, start, NULL, edges, (VOIDP)*array);
				return array;
			}
			sds_id = SDselect(sd_id, i);
			int32 start[setRank[i]], edges[setRank[i]];
			
			T** array = (T **)malloc(setDimensions[i][0] * sizeof(T *));
			array[0] = (T *)malloc(setDimensions[i][0] * setDimensions[i][1] * sizeof(T));
			
			for (int j = 1; j < setDimensions[i][0]; j++)
			{
				array[j] = array[0] + j * setDimensions[i][1];
			}
			start[0] = 0; start[1] = 0;
			edges[0] = setDimensions[i][0]; edges[1] = setDimensions[i][1];
			status = SDreaddata(sds_id, start, NULL, edges, (VOIDP)*array);
			return array;
		}
	}
	return NULL;
}

/**
 * Free the array generated by setToArray().
 */
template <class T>
void hdf4object::freeArray(T** array)
{
	for(unsigned int i = 0; i < sizeof(array) / sizeof(T*); i++)
		free(array[i]);
	free(array);
}

/**
 * Writes the data set to the specified file.  The data values are tab
 * delimited for easy loading into other applications.
 */
template <class T>
bool hdf4object::setToFile(std::string* setName, std::string* fileName)
{
	T** array = setToArray<T>(setName);
	
	if (array == NULL)
		return false;	
	std::ofstream f_out;
	f_out.open(fileName->c_str());
	int* dims = hdf4object::getSetDimensions(setName);
	for (int i = 0; i < dims[0]; i++) {
		for (int j = 0; j < dims[1]; j++)
			f_out << array[i][j] << '\t';
		f_out << std::endl;
	}
	f_out.close();
	freeArray<T>(array);
	return true;
}
#endif

